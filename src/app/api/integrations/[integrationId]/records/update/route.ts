import { NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/prisma";
import { authenticateSoftOneAPI, setSoftOneData } from "@/lib/softone-api";
import { decrypt } from "@/lib/encryption";

/**
 * POST /api/integrations/[integrationId]/records/update
 * Update a record - first updates SoftOne, then updates our DB
 */
export async function POST(
  request: Request,
  { params }: { params: Promise<{ integrationId: string }> }
) {
  try {
    const { integrationId } = await params;
    const session = await auth();

    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { recordId, data } = body;

    if (!recordId) {
      return NextResponse.json(
        { success: false, error: "recordId is required" },
        { status: 400 }
      );
    }

    // ADMIN can use any integration; others only their own
    const integration = await prisma.softOneIntegration.findFirst({
      where:
        session.user.role === "ADMIN"
          ? { id: integrationId }
          : { id: integrationId, userId: session.user.id },
      include: { connection: true },
    });

    if (!integration) {
      return NextResponse.json(
        { success: false, error: "Integration not found" },
        { status: 404 }
      );
    }

    const config = integration.configJson as any;
    const modelMapping = config?.modelMapping || {};
    const { modelName, fieldMappings, uniqueIdentifier, syncDirection } = modelMapping;
    const { erpField, modelField } = uniqueIdentifier || {};

    if (!modelName || !fieldMappings) {
      return NextResponse.json(
        { success: false, error: "Model mapping not configured" },
        { status: 400 }
      );
    }

    // Get the model dynamically
    const model = (prisma as any)[modelName];
    if (!model) {
      return NextResponse.json(
        { success: false, error: `Model ${modelName} not found` },
        { status: 400 }
      );
    }

    // Get primary key field
    const primaryKeyField = getPrimaryKeyField(modelName);
    
    // Parse recordId
    let parsedRecordId: string | number = recordId;
    if (modelName === "CUSTORMER" || modelName === "COUNTRY" || modelName === "VAT" || 
        modelName === "SOCURRENCY" || modelName === "TRDCATEGORY" || modelName === "ITEMS" || 
        modelName === "PAYMENT" || modelName === "INST" || modelName === "INSTLINES") {
      parsedRecordId = parseInt(recordId, 10);
      if (isNaN(parsedRecordId)) {
        return NextResponse.json(
          { success: false, error: "Invalid record ID" },
          { status: 400 }
        );
      }
    }

    // Get the existing record
    const existingRecord = await model.findUnique({
      where: {
        [primaryKeyField]: parsedRecordId,
      },
    });

    if (!existingRecord) {
      return NextResponse.json(
        { success: false, error: "Record not found" },
        { status: 404 }
      );
    }

    // For two-way sync, update SoftOne first
    if (syncDirection === "two-way") {
      try {
        // Authenticate with SoftOne
        const connection = integration.connection;
        const password = decrypt(connection.passwordEnc);

        const authResult = await authenticateSoftOneAPI(
          connection.username,
          password,
          String(connection.appId),
          String(connection.company),
          String(connection.branch),
          String(connection.module),
          String(connection.refid),
          undefined,
          connection.registeredName
        );

        if (!authResult.success || !authResult.clientID) {
          return NextResponse.json(
            { success: false, error: "Failed to authenticate with SoftOne" },
            { status: 401 }
          );
        }

        // Create reverse field mappings (modelField -> erpField)
        const autoGeneratedFields = ["INSDATE", "UPDDATE", "createdAt", "updatedAt", "SODTYPE", "id", "TRDR", "MTRL"];
        const reverseMappings: Record<string, string> = {};
        Object.entries(fieldMappings).forEach(([erpFieldName, modelFieldName]: [string, any]) => {
          if (autoGeneratedFields.includes(erpFieldName)) return;
          if (modelFieldName && modelFieldName !== "none" && modelFieldName.trim() !== "") {
            reverseMappings[modelFieldName] = erpFieldName;
          }
        });

        // Transform data to SoftOne format
        const softOneData: Record<string, any[]> = {};
        const objectData: any = {};

        // Merge existing record with new data
        const mergedData = { ...existingRecord, ...data };

        Object.entries(reverseMappings).forEach(([modelFieldName, erpFieldName]) => {
          if (autoGeneratedFields.includes(erpFieldName)) return;
          
          const value = mergedData[modelFieldName];
          if (value !== null && value !== undefined) {
            const intFields = ["COUNTRY", "SOCURRENCY", "ISACTIVE", "VAT", "VATS1", "VATS3", 
              "MYDATACODE", "DEPART", "ACNMSKS", "ACNMSKX", "LOCKID", "TRDCATEGORY", "SODTYPE", "ITEMS",
              "PAYMENT", "ISDOSE", "INSTALMENTS", "MATURE", "PAYROUND", "MATURE1", "INST", "BLOCKED",
              "INSTLINES", "LINENUM"];
            const floatFields = ["PERCNT", "MU21", "MU31", "MU41", "WEIGHT", "PRICEW", "PRICER", 
              "DIM1", "DIM2", "DIM3", "SALQTY", "PURQTY", "ITEQTY", "GWEIGHT", "INTERESTDEB", "INTERESTCRE",
              "QTY", "PRICE"];
            
            if (intFields.includes(erpFieldName)) {
              objectData[erpFieldName] = typeof value === "number" ? value : parseInt(String(value), 10);
            } else if (floatFields.includes(erpFieldName)) {
              objectData[erpFieldName] = typeof value === "number" ? value : parseFloat(String(value));
            } else if (typeof value === "number" && !Number.isInteger(value)) {
              objectData[erpFieldName] = value;
            } else {
              objectData[erpFieldName] = String(value);
            }
          }
        });

        // For ITEMS model, SoftOne table name is "MTRL", not "ITEMS"
        let objectName = integration.objectName || integration.tableName;
        if (modelName === "ITEMS") {
          objectName = "MTRL"; // SoftOne table name for items is MTRL
        }
        softOneData[objectName] = [objectData];

        // Get identifier for KEY
        // For CUSTORMER model, use TRDR as the KEY for SoftOne
        // For ITEMS model, use MTRL as the KEY for SoftOne
        let key: string;
        if (modelName === "CUSTORMER" && existingRecord.TRDR) {
          key = String(existingRecord.TRDR);
        } else if (modelName === "ITEMS" && existingRecord.MTRL) {
          key = String(existingRecord.MTRL);
        } else if (modelField && existingRecord[modelField]) {
          key = String(existingRecord[modelField]);
        } else {
          key = String(recordId);
        }

        // Build LOCATEINFO string for response data (optional, but recommended)
        // Format: "OBJECT:field1,field2;TABLE2:field1,field2"
        // For CUSTORMER, request key fields from CUSTOMER table (without CUSEXTRA)
        let locateInfo: string | undefined;
        if (modelName === "CUSTORMER") {
          // Request key fields from CUSTOMER table only (no CUSEXTRA)
          const keyFields = ["CODE", "NAME", "AFM"];
          locateInfo = `${objectName}:${keyFields.join(",")}`;
        } else if (modelName === "ITEMS") {
          // Request key fields from MTRL table (SoftOne table name for items)
          const keyFields = ["CODE", "NAME"];
          locateInfo = `MTRL:${keyFields.join(",")}`;
        }

        // Update in SoftOne using VERSION 2 (required for KEY-based updates)
        const setDataResult = await setSoftOneData(
          objectName,
          key,
          softOneData,
          authResult.clientID,
          connection.appId,
          "2", // Use VERSION 2 for KEY-based updates
          locateInfo // Optional LOCATEINFO to get response data
        );

        if (!setDataResult.success) {
          return NextResponse.json(
            { success: false, error: `Failed to update in SoftOne: ${setDataResult.error}` },
            { status: 500 }
          );
        }
      } catch (error) {
        console.error("[API] Error updating SoftOne:", error);
        return NextResponse.json(
          {
            success: false,
            error: error instanceof Error ? error.message : "Failed to update in SoftOne",
          },
          { status: 500 }
        );
      }
    }

    // Update in our database
    const updatedRecord = await model.update({
      where: {
        [primaryKeyField]: parsedRecordId,
      },
      data: data,
    });

    return NextResponse.json({
      success: true,
      record: updatedRecord,
    });
  } catch (error) {
    console.error("[API] Error updating record:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to update record",
      },
      { status: 500 }
    );
  }
}

function getPrimaryKeyField(modelName: string): string {
  const primaryKeys: Record<string, string> = {
    CUSTORMER: "id",
    User: "id",
    COUNTRY: "COUNTRY",
    IRSDATA: "IRSDATA",
    VAT: "VAT",
    SOCURRENCY: "SOCURRENCY",
    TRDCATEGORY: "TRDCATEGORY",
    ITEMS: "ITEMS",
    PAYMENT: "PAYMENT",
    INST: "INST",
    INSTLINES: "INSTLINES",
  };
  return primaryKeys[modelName] || "id";
}



